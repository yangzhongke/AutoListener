using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Diagnostics;

namespace AutoListener.SourceGenerator
{
    [Generator]
    public class AutoListenerSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a syntax receiver that will be created for every compilation
            // and collect candidates for generation.
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            var compilation = context.Compilation;
            var attributeSymbol = compilation.GetTypeByMetadataName("AutoListener.Core.EnableAutoListenerAttribute");

            foreach (var classDeclaration in receiver.CandidateClasses)
            {
                var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

                // Check if the class has the [EnableAutoListenerAttribute]
                var classSymbol = model.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                if (classSymbol == null || !classSymbol.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeSymbol)))
                    continue;

                // Generate the partial property methods
                var properties = classDeclaration.Members.OfType<PropertyDeclarationSyntax>()
                    .Where(p => p.Modifiers.Any(SyntaxKind.PartialKeyword));

                var sourceBuilder = new StringBuilder($@"namespace {classSymbol.ContainingNamespace}
{{
    public partial class {classSymbol.Name}
    {{
");

                foreach (var property in properties)
                {
                    var propertyName = property.Identifier.Text;
                    var propertyType = property.Type.ToString();

                    sourceBuilder.AppendLine($@"
        public partial {propertyType} {propertyName}
        {{
            get => field;
            set
            {{
                if (!Equals(field, value))
                {{
                    field = value;
                    OnPropertyChanged(nameof({propertyName}));
                }}
            }}
        }}
");
                }

                sourceBuilder.AppendLine("    }");
                sourceBuilder.AppendLine("}");

                context.AddSource($"{classSymbol.Name}_AutoGenerated.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
            }
        }

        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
                    classDeclaration.AttributeLists.Count > 0)
                {
                    CandidateClasses.Add(classDeclaration);
                }
            }
        }
    }

}
